2.1.14. Строки в Java
2.1.14.1. Объявление и инициализация строк
Для хранения и обработки строк в Java имеются два класса: String для неизменяемых строк и StringBuffer – для строк, которые могут меняться. Оба класса расширяют класс Object. Они находятся в пакете java.lang, поэтому их не надо подключать с помощью оператора import.
Строковые литералы в Java, как и в C, заключаются в двойные апострофы, например, "abc" задает строковый литерал abc.
 Если внутри строкового литерала необходимо задать символ апострофа, он задается с помощью символов \", например, "it\"s" задает строковый литерал it"s.
Инициализация объекта класса String может выполняться как с помощью оператора присваивания переменной класса String строковой переменной или строкового литерала, например:
String str = "Строка 1";
либо при создании объекта с помощью оператора new с использованием одного из следующих конструкторов класса  String:
•	String()– создается пустая строка;
•	String (String original) – содержимое строки original копируется в другую строку;
•	String (StringBuffer buffer) – содержимое строки buffer класса StringBuffer преобразуется в строку класса String;
•	String(byte[] bytes) –  строка создается из массива байт, с использованием кодировки на данном компьютере по умолчанию (для русского языка в Windows – кодировка Windows-1251);
•	String(byte[] bytes, int offset, int length) –  строка создается из части массива байт, начинающейся с индекса   offset и содержащей length байт;
•	String (char [] value) – строка создается из массива value символов Unicode;
•	String(char[] value, int offset, int length) — строка создается из части массива символов Unicode, начинающейся с индекса   offset и содержащей length символов.
Для String определены еще два конструктора, для создания строки с использованием заданной кодировки. Эти конструкторы будут рассмотрены позднее.

Длина строки может быть определена с помощью метода public int length(), например, "Строка 1".length() будет равно 8.
Единственная операция, которую можно использовать для строк, является операция сцепления (конкатенация) двух или более строк – "+". Например:
String S = "Первая" + " строка";
В результате выполнения этой операции строка S получит значение:
"Первая строка"
Операцию конкатенации используют при переносе длинной строки на другую строку, например:
String = "Эта строка настолько большая, что " +
"не помещается на одной строке";
Строки класса String можно изменять, но при каждом изменении длины строки создается новый экземпляр строки, например:
String S = "Строка 1,";
S += "Строка 1,";
В результате выполнения второго оператора будет создан новый экземпляр строки S.
Класс StringBuffer похож на класс String, но строки, созданные с помощью этого класса можно  модифицировать, т.е. их содержимое и длина могут меняться. Поэтому при изменении строки класса StringBuffer программа не создает новый строковый объект, а работает непосредственно с исходной строкой, т.е. все  методы оперируют непосредственно с бу¬фером, содержащим строку. Поэтому класс StringBuffer обычно используется, когда строку приходится часто модифицировать с изменением ее длины.
Размещение строк в объекте StringBuffer выполняется следующим образом. Для объекта StringBuffer задается размер или емкость (capacity) буферной памяти для строки. Строка символов в объекте StringBuffer, характеризуется своей длиной, которая может быть меньше или равна емкости буфера. Если длина строки меньше емкости буфера, то оставшаяся длина строки заполняется символом Unicode "\u0000". Если в результате модификации строки ее длина станет больше емкости буфера, емкость буфера автоматически увеличивается.
В классе StringBuffer имеется три конструктора, позволяющих по-разному создавать объекты типа StringBuffer:
StringBuffer()
StringBuffer(int length)
StringBuffer(String str)
Первый конструктор создает пустой объект StringBuffer с емкостью буферной памяти в 16 символов, второй конструктор задает буфера с емкостью length для хранения строки, а третий конструктор создает  объект StringBuffer из объекта String с емкостью буфера, равной длине строки класса String.
Длину строки в объекте StringBuffer можно так же, как и для строки класса String,  получить с помощью метода public int length(), а текущую емкость буферной области – с помощью метода public int capacity().
Помимо задания емкости буферной памяти в конструкторе, ее можно также установить с помощью метода
public void ensureCapacity(int minimumCapacity)
например:
StringBuffer str = new StringBuffer("String buffer");
str.ensureCapacity(512);
В отличие от методов обработки строк, имеющихся в классе String и создающих новую строку, методы класса StringBuffer работают непосредственно с буфером, в котором содержится исходная строка. Снача¬ла нужно установить длину строки с помощью метода
public void setLength(int newLength),
например:
StringBuffer str = new StringBuffer("String buffer");
str.setLength(40) ;
Единственный параметр этого метода – новая длина. Если новая длина больше старой, увеличиваются длины строки и буфера, при этом дополни¬тельные символы заполняются нулями. Если новая длина меньше старой, символы в конце строки отбрасываются, а размер буфера не изменяется.
Метод
public String toString()
преобразует строку StringBuffer в строку String, т.е. выполняет то же самое, что и третий из приведенных выше конструкторов класса String.
2.1.14.2. Сравнение строк
Поскольку в Java строки являются объектами, для сравнения строк можно использовать оператор "==" и метод
public boolean equals(Object anObject),
сравнивающей строку, для которой вызывается метод, с объектом anObject. Результат будет true, только если anObject является строкой и значения сравниваемых строк равны.
Использование оператора "==" для сравнения строк может привести к неверному результату, если сравниваемые строки – разные объекты, поэтому  более предпочтительным является использование метода equals() (этот метод работает и для строк String и для строк StringBuffer).
Пример сравнения строк.
String str1 = new String("Строка");
String str2 = new String("Строка");
int x;
if (str1.equals(str2))
	x =0;

Наряду с  методом equals() для строк класса String, определены следующие методы (все методы имеют модификатор public):
•	boolean equalsIgnoreCase(String anotherString) – сравнение значений строк без учета регистра букв;
•	boolean startsWith(String prefix) – проверка, содержится ли строка prefix в начале проверяемой строки;
•	boolean startsWith(String prefix, int toffset) – проверка, содержится ли подстрока строки prefix, начиная с позиции toffset в начале проверяемой строки;
•	boolean endsWith(String suffix) – проверка, содержится ли строка prefix в конце проверяемой строки;
•	int compareTo(String anotherString) – лексикографически сравнивает две строки и возвращает 0, если строки равны по длине и имеют одинаковое, значение, меньшее 0, если в первой позиции, в которой символы строк не равны, код символа в первой строке меньше кода символа во второй строке или длина первой строки меньше длины второй строки все символы первой строки равны символам в тех же позициях второй строки. Если в первой позиции, в которой символы строк не равны код символа в первой строке больше кода символа во второй строке или длина первой строки больше длины второй строки, возвращается значение, больше 0;
•	boolean regionMatches(int toffset, String other, int ooffset, int len) – сравнивает len символов в двух строках, причем в первой строке сравниваемые символы начинаются с позиции  toffset , а во второй строке other – с позиции ooffset;
•	boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) – выполняет ту же операцию, что и предыдущий метод, но если значение ignoreCase при вызове метода равно true, то регистры букв в сравниваемых подстроках игнорируются.

Пример сравнения строк с помощью метода regionMatches().
String S1 = new String("Строка1");
String S2 = new String("Новая строка");
int x;
...
if (S1.regionMatches(true, 0, S2, 6, 6))
	x = 1;
Значение выражения в скобках будет равно true, поскольку первые 6 символов строки S1 ("Строка") совпадают с шестью символами строки S2, начиная с индекса 6 ("строка"), без учета регистра символов.
2.1.14.3. Поиск в строках
Для поиска символов или последовательностей символов (только в строках класса String) используются следующие перегружаемые методы indexOf() (все эти методы имеют модификатор public):
•	int indexOf(int ch) – возвращает первую позицию в строке, в которой встречается символ ch;
•	public int indexOf(int ch, int fromIndex) – возвращает  первую позицию в строке, начиная с позиции fromIndex,в которой встречается символ ch;
•	int indexOf(String str) – возвращает первую позицию в строке, в которой встречается строка str;
•	public int indexOf(String str, int fromIndex) – возвращает  первую позицию в строке, начиная с позиции fromIndex,в которой встречается строка str.
Для каждого метода indexOf() имеется соответствующий метод lastIndexOf(), который  начинает поиск символа или строки не с начала, а с конца строки. Если символ или строка не найдены в строке, в которой производится поиск, методы indexOf() и lastIndexOf() возвращают значение -1.

Пример поиска символа и строки с помощью метода indexOf():
String S1 = new String("Строка1");
String S2 = new String("Новая строка");
int x, y;
...
x = S1.indexOf('к', 1);		// x = 4
y = S2.indexOf("строка");	// y = 6
2.1.13.4. Извлечение символов и подстрок из строки
Извлечение символов и подстрок из строк String и StringBuffer выполняется с помощью следующих методов (все методы имеют модификатор public):
•	char charAt(int index) – возвращает значение символа строки в позиции index;
•	char[] toCharArray() – возвращает массив символов – копию строки;
•	String substring(int beginIndex) – возвращает строку, начинающуюся с позиции beginIndex исходной строки и до конца строки;
•	String substring(int beginIndex, int endIndex) – возвращает  строку, начинающуюся в позиции beginIndex и заканчивающуюся в позиции, на единицу меньшей  endIndex в исходной строке;
•	void getChars (int srcBegin, int srcEnd, char[] dst, int dstBegin) – копирует часть строки, начиная с символа в позиции  srcBegin и заканчивая символом в позиции dstBegin + (srcEnd - srcBegin) - 1 в символьный массив dst, начиная с позиции dstBegin.

Пример извлечения символов строки в символьный массив с помощью метода getChars():
StringBuffer str = new StringBuffer("String buffer");
char ch[] = new char[20];
str.getChars(7, 10, ch, 0);
2.1.14.5. Модификация строк
Для строк класса String определены следующие методы public для модификации строк:
•	String concat(String str) – возвращает исходную строку, в конец которой добавлена строка str;
•	String toLowerCase() – возвращает строку, в которой все буквы переведены в нижний регистр (независимо от языка);
•	String toUpperCase() – возвращает строку, в которой все буквы переведены в верхний регистр (независимо от языка);
•	String trim() – возвращает строку, в которой удалены все пробельные символы (символы с кодами, не превышающими '\u0020') в начале и в конце строки;
•	String replace(char oldChar, char newChar) – заменяет в строке все символы oldChar на newChar.

Пример замены символа в строке с помощью метода replace():
Оператор "a:b:c:d".replace(':',',')
вернет строку "a,b,c,d".

Для создания строк из примитивных типов данных в классе String используются перегруженные статические методы valueOf(), в качестве аргумента которых задается константа, переменная или выражение примитивного типа (boolean, char, int, long, float, или double). Возвращаемым значение метода является строка класса String – строковое представление аргумента, например, String.valueOf(15) возвращает строку "15". Кроме того, определены еще две версии методов valueOf():
•	static String valueOf(char[] data) – возвращает строковое представление символьного массива data;
•	static String valueOf(char[] data, int offset, int count) – возвращает строковое представление символьного массива data, начиная с позиции offset и размером count.

Как уже говорилось, методы класса StringBuffer могут непосредственно модифицировать строку.
Так, метод
public void setCharAt(int index, char ch)
позволяет поместить в указанной позиции заданный символ, например:
StringBuffer str = new StringBuffer("String buffer");
str.setCharAt(3, 'X');
В приведенном примере переменная str после выполнения метода setCharAt() будет содержать символы "StrXng buffer".
Можно также удалить символ в заданной позиции строки, используя метод
public void deleteCharAt(int index),
например:
StringBuffer str = new StringBuffer("String buffer");
str.deleteCharAt(2);
После удаления символа 'r' длина строки уменьшится на 1 и строка str будет иметь значение "Sting buffer".
Замена символов строки выполняется с помощью метода
public StringBuffer replace(int start, int end, String str),
который заменяет подстроку в строке, начиная с символа в позиции start и до символа в позиции end-1 строкой str, например:
StringBuffer str = new StringBuffer("String buffer");
str.replace(0,6,"Array");
После замены строка будет иметь вид "Array buffer" и длина строки уменьшится на 1.
Символы в конец строки можно добавить при помощи метода
public StringBuffer append(тип-параметра имя-параметра),
а вставить символы в любом месте строки, начиная с позиции offset, можно с помощью мето¬да
public StringBuffer insert(int offset,
тип-параметра имя-параметра).
Оба метода имеют несколько версий, позволяющих обрабатывать различные типы данных. Для append и insert тип-параметра может принимать следующие значения:
Object         	String        	char[]
boolean        	char       	int
long           	float         	double
Например, для добавления строкового представле¬ния целого числа в конец строки нужно выполнить такие операторы:
StringBuffer str = new StringBuffer("String buffer");
int value = 15;
str.append(value);
После выполнения операторов переменная str будет содержать символы "String buffer15". Аналогичным образом можно вставлять символы:
StringBuffer str = new StringBuffer("String buffer");
int value = 15;
str.insert(6, value);
В результате выполнения этих операторов получится строка "String15 buffer".
Существуют также методы
public StringBuffer append(char[] str, int offset, int len)
и
public StringBuffer insert(int offset0,
char[] str, int offset1, int len),
которым в качестве аргумента передается часть массива char, начиная с индекса offset и длиной len.
2.1.15. Объектные надстройки примитивных типов
Многие классы в Java предпочитают работать не с примитивными типами дан¬ных, а с объектами, поскольку для объектов можно задавать свойства и методы. Именно с этой целью в Java введены классы – объектные надстройки над примитивными типами. Новые объекты, например, числа в этих классах задаются с помощью оператора new и над ними нельзя выполнять операции, определенные для примитивных типов (например, сложение), однако они часто используются для выполнения некоторых операций, реализуемых с помощью методов соответствующего класса-надстройки. Все классы-надстройки автоматически доступны программе, поскольку они находятся в пакете java.lang.
2.1.15.1. Класс Character
Класс Character обеспечивает надстройку для примитивного типа char. Конструктор public Character(char value) имеет один параметр: сим¬вол, который он будет представлять.
Чтобы получить хранимое в объекте значение типа char, можно воспользо¬ваться методом public char charValue().
В классе Character определены также следующие основные статические public-методы для классификации символов:
•	boolean isDigit(char ch) – проверка, является ли символ ch цифрой от 0 до 9;
•	boolean isLetter(char ch) – проверка, является ли символ ch буквенным символом;
•	boolean isLetterOrDigit(char ch)– проверка, является ли символ ch буквенным символом или цифрой;
•	boolean isJavaLetter(char ch) – проверка, является ли символ ch буквой Java, т.е. буквой, символом '$' или символом '_';
•	boolean isJavaLetterOrDigit(char ch) – проверка, является ли символ ch буквой Java или цифрой;
•	boolean isLowerCase(char ch) – проверка, является ли символ ch буквой нижнего регистра;
•	boolean isUpperCase(char ch) – проверка, является ли символ ch буквой верхнего регистра;
•	boolean isWhitespace(char ch) – проверка, является ли символ ch пробелом, символом перевода строки, символом возврата каретки, символом табуляции или символом перевода страницы.
Напри¬мер, значением
Character.isLetter ('а')
будет true, а вызов
Character.isDigit ('а')
возвратит значение false.
Метод
int compareTo(Character anotherCharacter)
сравнивает коды символов и выдает значение меньше 0, если код сравниваемого символа меньше кода символа anotherCharacter, значение 0, если коды символов равны и  значение больше 0, если код сравниваемого символа больше кода символа anotherCharacter.
Методы
public static char toUpperCase(char ch)
и
public static char toLowerCase(char ch)
приводят символ к верхнему и нижнему регистру соответственно.
Метод
public static int digit(char ch, int radix)
возвращает численное значение, представляемое символом в заданной системе счисления (система счисления задается параметром radix, например, 10 для десятичной или 8 для восьмеричной системы счисления).
Метод
public static char forDigit(int digit, int radix)
преобразует численное значение в символ заданной сис¬темы счисления. Например, Character.forDigit (6, 8) вернет значение '6', a Character.forDigit (12,16) возвратит 'с'.
2.1.15.2. Класс Boolean
Класс Boolean является объектной надстройкой над типом boolean. Переменные класса Boolean
public static final Boolean FALSE
и
	public static final Boolean TRUE
являются объектными представлениями значений false и true.
В классе Boolean определены два конструктора: одному передается параметр типа boolean, а другому – строковое представление значения типа boolean:
public Boolean(boolean value)
public Boolean(String str)
Во втором варианте конструктора создается значение false, если параметр str не равен "true" (перед сравнением str приводится к нижнему регистру), например оператор:
Boolean bool1 = new Boolean("1");
создает переменную класса Boolean со значением Boolean.FALSE.
Метод
public static String toString(boolean b)
возвращает строковое представление булевского значения false или true, а метод
public String toString()
возвращает строковое представление значения объекта Boolean.
Методы
public static Boolean valueOf(boolean b)
и
public static Boolean valueOf(String s)
выполняют те же действия, что и конструкторы класса Boolean.
2.1.15.3. Класс Number
Объектные надстройки для типов int, byte, short, long, float и double являются производными от абстрактного класса Number. Это означает, что любому классу, ожидающему аргумент Number, можно передать в качестве параметра экзем¬пляр класса Byte, Short, Integer, Long, Float или Double. Четыре метода класса Number отвечают за преобразование числа к конкретному базовому типу:
public abstract int byteValue();
public abstract int shortValue();
public abstract int intValue();
public abstract long longValue();
public abstract float floatValue();
public abstract double doubleValue().
Конкретные реализации этих методов  преобразуют объект класса  Byte, Short, Integer, Long, Float или Double в значение соответствующего примитивного типа.
2.1.15.4. Классы Byte, Short, Integer и Long
Класс Byte реализует объектную надстройку над примитивным типом byte  и обеспечива¬ет методы преобразования целых чисел типа byte  в строки и наоборот. Объект Byte можно создать из числа типа byte или из строки:
public Byte (byte value)
public Byte (String s)
В классе Byte есть также методы
public static byte parseByte(String s)
и
public static Byte valueOf(String s)
для преобразования строк в целые числа, представленные как byte или как Byte.
Для преобразования чисел типа byte  в строку можно применить метод
public static String toString(byte i).
Класс Short аналогичен классу Byte, но обеспечивает надстройку над числами примитивного типа short. Его конструкторами являются:
public Short (short value)
public Short (String s)
В классе Short также есть методы
public static int parseShort(String s)
и
public static Short valueOf(String s)
для преобразования строк в целые числа, представленные как short или как Short. Методы для преобразования чисел типа short в числа других типов в классе Short аналогичны тем же методам класса Byte. Числа типа short преобразовываются в строку с помощью метода static String toString(short i).
Класс Integer реализует объектную надстройку над примитивным типом int. Объект Integer можно создать из целого числа или из строки:
public Integer(int value)
public Integer(String s)
В классе Integer также есть методы
public static int parseInt(String s)
и
public static Integer valueOf(String s)
для преобразования строк в целые числа, представленные как int или как Integer.
Для преобразования целого в строку можно применить метод
public static String toString(int i).
Класс Integer содержит также методы
public static String toBinaryString(int i);
public static String toHexString(int i);
public static String toOctalString(int i);
преобразующие целое число в строку соответственно в двоичном, шестнадцатеричном или восьмеричном представлении.
Класс Long служит надстройкой над примитивным типом long. Его конструкторы
public Long(long value)
и
public Long(String s),
а также методы
public static long parseLong(String s),
public static Long valueOf (String s)
и
public static String toString(long i)
действуют аналогично соответствующим методам класса Byte.
2.1.15.5. Классы Float и Double
Класс Float является надстройкой над типом float, представляющим числа с плавающей точкой. Реализация объекта типа Float обеспечивается конструкторами
public Float(float value),
public Float(double value)
и
public Float(String s).
Преобразование объекта типа Float в строку и обратное преобразование обеспечивается соответственно методами
public static Float valueOf(String s)
и
public static String toString(float f).
В плавающей арифметике существуют специальные константы, обозначающие бесконечность, а также «не число» (NaN— Not a Number). Проверить число на совпадение с этими константами можно при помощи методов
public static boolean isInfinite(float f)
и
public static boolean isNaN(float f).

Класс Double с конструкторами
public Double(double value)
и
public Double(String s)
обеспечивает те же функции, что и Float, но служит объектной надстройкой над примитивным типом double.
Методы
public static String toString(double d),
public static Double valueOf(String s),
public static boolean isInfinite(double d)
и
public static boolean isNaN(double d)
действуют аналогично соответствующим методам класса Float.
2.1.16. Математические классы в Java
2.1.16.1. Классы StrictMath и Math
Классы StrictMath и Math в пакете java.lang представляют собой набор полезных числовых констант и математических функций. Поскольку эти классы заданы с модификатором final, нельзя расширять, и, соответственно, нельзя переопределять их свойства и методы.
Классы StrictMath и Math содержат одинаковый набор свойств и методов, однако алгоритмы реализации их методов имеют следующие отличия:
Чтобы обеспечить переносимость программ на языке Java, алгоритмы методов в классе StrictMath взяты из хорошо известной сетевой библиотеки netlib пакета свободно распространяемой математической библиотеки fdlibm (Freely Distributable Math Library). Эти алгоритмы, написанные на языке C, были переписаны в соответствии с правилами выполнения операций с плавающей арифметикой в языке Java.
Алгоритмы методов в пакете Math ориентированы на оптимизацию скорости вычислений на основе использования особенностей микропроцессорных команд той или иной компьютерной платформы. Поэтому методы в пакете Math выполняются быстрее, однако результаты выполнения некоторых методов для одних и тех же аргументов могут отличаться на значения одного или двух младших битов.
Классы StrictMath и Math содержат два свойства: static double E – значение константы e и static double PI – значение константы .

Пример использования PI:
double R = 2.55;
double x = Math.PI  *  R * R;

Как указывалось выше, набор методов классов StrictMath и Math одинаков, поэтому в дальнейшем рассматриваются только методы класса Math.
Метод abs(), возвращающий абсолютную величину числа, преобразует отрицательные числа в противоположные по знаку, а положительные оставля¬ет без изменений. Есть четыре варианта этого метода:
public static int abs(int a);
public static long abs(long a);
public static float abs(float a);
public static double abs(double a);
Метод
public static double pow(double x, double y)
возвращает значение xy, а метод
public static double sqrt(double x) –
значение  , например:
int  x = 2, y = 9, z;
z = Math.pow((double)x, 4.0);   	// z = 16
z = Math.sqrt((double)y);		// z = 3
В случае, если основание степени равно числу e, для возведения числа в степень можно использовать метод
public static double exp(double x).
Метод
public static double log(double x)
возвращает значение натурального логарифма числа x. Методов вычисления десятичного и двоичного логарифма в Java нет, однако они легко получаются из натурального логарифма с помощью следующих выражений:
double x = 2.1, logx10, logx2;
logx10 = Math.log(x)/Math.log(10.0);
logx2 =  Math.log(x)/Math.log(2.0);
Если аргумент метода sqrt() или метода log() меньше нуля, то возвращается значение NaN.
Для тригонометрических статических public-методов  класса Math: синуса –sin(), косинуса – cos(), тангенса – tan(), арксинуса – asin(), арккосинуса – acos() и арктангенса – atan() аргумент задается в радианах как число или выражение типа double. Возвращаемое методами значение также имеет тип double.
Метод
public static double atan2(double y, double x)
определяет угол в полярных координатах для точки с координатами (x, y) в прямоугольных (декартовых) координатах (другой компонент полярных координат – радиус, равен  ).
Метод
public static double toDegrees(double rad)
преобразует значение угла в радианах в значение в градусах, а метод
public static double toRadians(double grad)
выполняет обратное преобразование.
В классе Math определены следующие методы округления:
public static double floor(double x) – возвращает ближайшее целое значение числа с двойной точностью, меньшее или равное x;
public static double ceil(double x) – возвращает ближайшее целое значение числа с двойной точностью, большее или равное x;
public static int round(float x) – возвращает округленное значение числа x до ближайшего целого;
public static double rint(double x) – возвращает округленное значение числа x до ближайшего целого значения числа с двойной точностью.
Методы
min(тип x, тип y)
и
max(тип x, тип y),
возвращающие соответственно меньшее из двух чисел и большее из двух чисел, существуют в четырех вариантах для значений типа int, long, float и double.
Для определения остатка от деления двух чисел с плавающей точкой в классе Math определен метод
public static double IEEEremainder(double f1, double f2),
возвращающий остаток от деления в соответствии со стандартом IEEE 754.
В класс Math включен также генератор случайных чисел, вызываемый с помощью метода
public static double random()
Этот метод возвращает число с двойной точностью, равномерно распределенное в диапазоне от 0.0 до  1.0.
2.1.16.2. Класс Random
Класс Random в пакете java.util предоставляет более гибкий генератор случайных чисел, чем генератор из класса Math. При использовании класса Random в программе, необходимо задать импорт этого класса или всего пакета java.util в операторе import. Поскольку методы класса Random нестатические, для генерации случайных чисел должен быть создан экземпляр Random. Для этого проще всего использовать пустой конструктор:
public Random();
Одним из удобных свойств в классе Random является возможность установки начального числа последовательности случайных чисел. При создании объекта Random каждый раз с оди¬наковым начальным числом получаются одинаковые последовательности случайных чисел. Это свойство генератора случайных чисел часто используется  при написании программ моделирования, где одна и та же последовательность повторяется несколько раз. Пустой конструктор использует в качестве на¬чального числа значение текущего времени в компьютере (в миллисекундах) – целое  число типа long, возвращаемое при вызове статического метода класса System библиотеки Java:
public static long currentTimeMillis()
Чтобы создать объект класса  Random с конкретным начальным числом, следует передать конструктору это значение в качестве параметра:
public Random(long seed);
Начальное число можно изменить в любой момент при помощи метода
public void setSeed(long newSeed).
В классе Random определены также следующие методы:
•	protected int next(int bits) – возвращает следующее целое число (подкласс класса Random должен переопределить  этот метод, т.к. он используется всеми остальными методами класса Random);
•	public boolean nextBoolean() – возвращает следующее равномерно распределенное булевское случайное значение (true или false);
•	public void nextBytes(byte[] bytes) – возвращает случайные байты и помещает их в массив байт (количество сгенерированных байтов равно длине массива);
•	public int nextInt() – возвращает  случайное равномерно распределенное целое число, двоичное значение которого может иметь любое значение в диапазоне от 0 до 232;
•	public int nextInt(int n) – возвращает случайное равномерно распределенное целое число x в диапазоне 0  x < n;
•	public long nextLong() – возвращает случайное равномерно распределенное целое число типа long, двоичное значение которого может иметь любое значение в диапазоне от 0 до 264;
•	public float nextFloat() – возвращает случайное равномерно распределенное число x типа float в диапазоне 0.0  x < 1.0;
•	public double nextDouble() – возвращает  случайное равномерно распределенное число x типа double в диапазоне 0.0  x < 1.0;
•	public double nextGaussian() – возвращает число типа double, распределенное по нормальному (гауссову) закону со средним значением, равным 0.0 и стандартным отклонением, равным 1.0.

2.2.6. Регулярные выражения в Java
2.2.6.1. Основные сведения о регулярных выражениях
Функции работы с подстроками позволяют выполнить операции поиска подстрок в строке и замены подстрок в строке. Однако при работе с данными часто приходится выполнять операции поиска и замены по довольно сложным алгоритмам, например, найти первое вхождение цифры в строке. Хотя такие операции можно выполнить, используя функции работы со строками, условные операторы и операторы цикла, в языке Java, как и в других языках программирования, существует более удобный способ – использование регулярных выражений.
Регулярные выражения используются для решения следующих задач:
•	проверки данных на наличие некоторой последовательности данных, заданных с помощью определенного образца, называемого шаблоном (pattern);
•	замены или удаления данных;
•	извлечения некоторой последовательности из данных.
Синтаксис регулярных выражений в Java в основном такой же, как и в других языках программирования.
2.2.6.1.1. Синтаксис регулярного выражения
Регулярное выражение в языке Java является объектом класса String, т.е. является строкой – последовательностью символов.
Символы в строке могут быть следующих типов:
•	алфавитно-цифровые символы, включая буквы кириллицы;
•	символ '\\' – обратная косая черта (обратный слеш);
•	символ '\0num' – восьмеричное число, где num – одна, две или три восьмеричные цифры;
•	символ '\xhh' – код символа ASCII, где hh – две шестнадцатеричные цифры;
•	символ '\uhhhh' – код символа Unicode, где hhhh – четыре шестнадцатеричные цифры;
•	символ табуляции ('\t'  или '\u0009');
•	символ новой строки ('\n'  или '\u000A');
•	символ возврата каретки ('\r'  или '\u000D');
•	символ перехода к новой странице ('\f'  или '\u000C');
•	символ звукового сигнала ('\a'  или '\u0007');
•	символ Escape (Esc) ('\u001B');
•	символ '\cx' – соответствует управляющему символу x  (например, \cM соответствует символу Ctrl+M или символу возврата каретки).
Некоторые символы в регулярных выражениях,  называемые метасимволами, имеют особое значения. Метасимволами являются следующие символы:
^ $ ( ) \ | [ { ? . + *
Именно использование метасимволов обеспечивает всю мощь и гибкость регулярных выражений.
Если  в регулярном выражении необходимо рассматривать метасимвол как обычный символ, перед ним надо поставить символ '\\', например, "\\(".
2.2.6.1.2. Операция альтернации
В регулярных выражениях можно объединять несколько шаблонов, так чтобы найденная строка соответствовала хотя бы одному из них. Для решения по¬добной проблемы служит операция альтернации, которая в регулярных выражениях задается символом "|", например шаблон "Internet|Интернет" означает поиск в исходной строке либо строки "Internet", либо строки "Интернет".
2.2.6.1.3. Одиночный метасимвол
Метасимвол точка "." внутри регулярного выражения точка соот¬ветствует любому одиночному символу, кроме символа перевода строки.

Пример использования одиночного метасимвола в регулярных выражениях
"с.р"
В этом шаблоне точка означает любой символ. Этому шаблону соответствуют слова сор, сыр, сарай,  и кассир. Точка заменяет только один символ. Поэтому слова срок, стирка и сатира не соответствуют указанному шаблону, поскольку в первом слове между символами с и р нет никакого символа, а во втором и третьем словах между этими символами расположены более одного символа.
2.2.6.1.4. Квантификаторы
Квантификаторы – это метасимволы, используемые для указания количественных отношений между символами в шаблоне и в искомой строке. Квантификатор может быть поставлен после одиночного символа или после группы символов.
Простейшим квантификатором является метасимвол "+". Он означает, что идущий перед ним символ соответствует нескольким идущим подряд таким символам в строке поиска. Количество символов может быть любым (максимально большим в рамках соответствия шаблону), но должен присутствовать хотя бы один символ.

Пример использования метасимвола "+" в регулярных выражениях
"ком+а"
Этому шаблону будут соответствовать слова команда и  коммандос, а слово коалиция соответствовать не будет.

Действие метасимвола "*" похоже на действие метасимвола "+". Метасимвол "*" указывает, что идущий перед ним символ встречается нуль или более раз.

Пример использования метасимвола "*" в регулярных выражениях
"точе*к"
Этому шаблону соответствуют слова точек и  точка, а слово точечный соответствовать не будет.

Метасимвол "?" указывает, что предшествующий ему символ должен встречаться либо один раз, либо не встречаться вообще.

Пример использования метасимвола "?" в регулярных выражениях
"ком?а"
Этому шаблону будут соответствовать слова команда и коалиция, а слово  коммандос соответствовать не будет.
Если необходимо указать точно количество повторений символа, можно воспользоваться конструкцией
{n,m}
Здесь n – минимально допустимое количество повторений предшествующего символа, m – максимально допустимое количество повторений. Один из параметров n или m можно опустить.

Примеры использования шаблона с указанием точного числа повторений символов в регулярных выражениях
1. "10{3,5}1" –  0 встречается как минимум 3 раза, но не более 5 раз. Числа 10001, 100001 и 1000001 удовлетворяют этому условию, а числа 1001 и 10000001 – нет.
2. "10{3,}1" –  0 встречается 3 или более раз. Двоичные числа 10001, 100001, 1000001, 10000001 и т.д. удовлетворяют этому условию, а числа 101 и 1001 – нет.
3. "10{0,3}1" –  0 встречается не более 3 раз, но может вообще не встретиться. Числа 11, 101, 1001 и 10001 удовлетворяют этому условию, а числа 100001, 1000001 и т.д. – нет.
4. "10{3}1" –  0 встречается ровно 3 раза. Двоичное число 10001 удовлетворяет этому условию, а числа 101, 1001, 100001 и т.д. – нет.

Фактически квантификаторы "+", "*" и "?" являются частными случаями конструкции {n,m}: соответственно, {1,}, {0,} и {0,1}.

В регулярных выражениях часто используют сочетание метасимволов ".*". Ему соответствуют любые символы. По правилам обработки регулярных выражений находится самая длинная строка, все еще удовлетворяющая шаблону поиска.
Если необходимо ограничить поиск, следует после квантификатора (в том числе и символа "?") указать символ "?".

Пример использования метасимволов ".*" в регулярных выражениях
Если задать для исходной строки
"Первый может стать как последний и последний может стать как первый."
шаблон
"первый.*последний"
(без учета регистра букв), то результатом поиска будет строка
"Первый может стать как последний и последний"
Если заменить шаблон на
"первый.*?последний"
то строка – результат поиска будет иметь следующий вид
"Первый может стать как последний"
2.2.6.1.5. Классы символов
Для поиска в регулярных выражениях можно задавать также классы символов, заключенные в квадратные скобки. Во время поиска все символы в классе рассматриваются как один символ. Внутри класса можно задавать диапазон символов (когда такой диапазон имеет смысл), по¬мещая дефис между границами диапазона. Внутри символьных классов большинство метасимволов теряют свои значения и становятся обыкновен¬ными символами.

Примеры задания классов символов в регулярных выражениях
1. "[абвг]" или "[а-г]" – любой из символов "а", "б", "в"  или "г". Строка "огонь" удовлетворяет шаблону, поскольку в ней есть символ  "г", а строка "окно" – не удовлетворяет, поскольку в ней нет ни одного из символов, указанных в шаблоне.
2. "Глава [0-9]+" – символы "Глава", за которыми (через пробел) следует одна или несколько цифр.  Строки "Глава 5" и "Глава 18" удовлетворяет шаблону, поскольку в них после строки "Глава" и пробела следуют соответственно одна и две цифры, а строка "Глава десять" – не удовлетворяет, поскольку в ней после слова "Глава" и пробела нет ни одной цифры.
3. "[А-Я][а-я]+" – заглавная буква, за которой следует одна или несколько строчных букв. Строка "Иванов" удовлетворяет шаблону, поскольку она начинается с заглавной буквы, за которой следуют строчные буквы, а строка "ивановский" – не удовлетворяет, поскольку она начинается со строчной буквы.
4. "[.?!]" – один из символов окончания предложения (обратите внимание, что символы "."  и "?" здесь используются как обычные символы, а не как метасимволы).  Строки "Как дела?", "Замечательно!" и "Хорошо." удовлетворяет шаблону, поскольку они содержат символы окончания предложения, а строка "Плохо" – не удовлетворяет, поскольку она не содержит ни одного символа окончания предложения.

Если первым символом класса является знак вставки "^", то значение выражения инвертируется. Другими словами, такому классу соответствует любой символ, не входящий в класс.

Примеры задания инвертированного класса в регулярных выражениях
"[^А-Я ]"
Этому шаблону удовлетворяет строка, содержащая хотя бы один символ, не являющийся заглавной буквой или пробелом.  Строки "Щит и меч", "МВД и МИД" удовлетворяет шаблону, поскольку они содержат строчные буквы, а строка "ЩИТ И МЕЧ" – не удовлетворяет, поскольку она содержит только заглавные буквы и пробелы.

Так как в классах символы "]", "^" и "-" имеют специальное значение, для их использо¬вания в классе существуют определенные правила:
•	литерал "^" не должен быть первым символом класса;
•	перед литералом "]" должен стоять символ обратной косой черты;
•	для помещения в класс символа "-" достаточно либо поставить его на первую позицию, либо поместить перед ним символ обратной косой черты.

Примеры задания шаблонов с учетом правил для символов "]", "^" и "-" в регулярных выражениях
1. "[^&*%^]" – строка содержит хотя бы один символ, не являющийся одним из символов "&", "*", "%" или "^".
2. "[[\]]" – строка содержит символ "[" или символ "]".
3. "[;:\-]]" – строка содержит символ ";" , символ ":" или символ "-".
2.2.6.1.6. Специальные символы
Наиболее распространенные классы символов можно задать с помощью следующих специальных символов:
•	\d – соответствует любому цифровому символу (эквивалентно [0-9]);
•	\D – соответствует любому нецифровому символу (эквивалентно [^0-9]);
•	\w – соответствует любой латинской букве или цифре (эквивалентно   [A-Za-z0-9]);
•	\W – соответствует любому небуквенному (латинскому) и нецифровому символу (эквивалентно [^A-Za-z0-9]);
•	\s – соответствует любому пробельному символу (эквивалентно [\f\n\r\t\v]);
•	\S – соответствует любому непробельному символу (эквивалентно [^\f\n\r\t\v]).
Следует отметить,  что специальные символы \w и \W нельзя использовать для букв кириллицы, а также букв западноевропейских алфавитов, отличных от латинских букв. В этом случае необходимо напрямую задавать диапазон символов, как это делается для классов символов.

Пример использования классов символов в регулярных выражениях
Шаблон для номера мобильного телефона имеет следующий вид:
"\\d{3}-\\d{3}-\\d\\d-\\d\\d"
Этому шаблону соответствует телефонный номер 067-745-12-18 и не соответствует номер 055-867-1567 (нет тире перед предпоследней цифрой номера).
2.2.6.1.7. Анкеры
С помощью анкеров можно указать, в каком месте строки должно быть найдено соответствие с шаблоном.
В Java определены следующие анкеры:
•	^ – соответствует позиции в начале строки;
•	$ – соответствует позиции в конце строки;
•	\b – соответствует границе слова, т.е. границе между словом и пробельным символом;
•	\B – соответствует не границе слова.
К сожалению, анкеры \b и \B действуют только для строк, состоящих из латинских букв.

Пример использования анкеров в регулярных выражениях
Шаблон
"^Глава \\d{1,2}\..*"
Ищет в исходной строке следующие соответствия: строка "Глава" в начале строки, затем пробел, затем одна или две цифры, затем точка, затем любое содержимое до конца строки.
2.2.6.1.8. Группировка элементов и обратные ссылки
Операция группировки элементов, т.е. заключение группы элементов в круглые скобки, позволяет рассматривать данную группу элементов как один элемент.

Предположим, что необходимо найти в строке одно из следующих слов:
белый, красный, зеленый, желтый или черный
Эту операцию можно выполнить, задав в качестве шаблона выражение
"белый|красный|зеленый|желтый|черный",
однако, с учетом того, что все приведенные слова имеют одинаковое окончание "ый", можно данный шаблон записать короче, используя группировку символов:
"(бел|красн|зелен|желт|черн)ый"
Допускается вложение скобок, а, следовательно, и вложение групп, поэтому предыдущий пример можно записать и таким образом:
"(бел|желт|(крас|зеле|чер)н)ый".

Если в регулярных выражениях используются скобки, части искомой строки, соответствующие фрагментам в скобках, запоминаются в специальных переменных $1 (первый фрагмент в скобках), $2 (второй фрагмент в скобках), $3 (третий фрагмент в скобках) и т.д. Такая операция называется захватом (capture) переменной.
Для вложенных скобок переменные $1-$9 формируются в порядке появления левой (открывающей) скобки выражения. При использовании группировки свойство lastParen (сокращение $+) объекта RegExp возвращает последнюю найденную группу символов.
Следует отметить, что  переменные  модифицируются при каждом успешном поиске, независимо от использования в регулярном выражении скобок. Кроме того, значения этих переменных устанавливаются тогда и только тогда, когда строка полностью соответствует шаблону. В противном случае значения этих переменных равны пустой строке.

Пример использования операции группировки в регулярных выражениях
Скобки в шаблоне мобильного телефона
"((\\d{3})-(\\d{3}-\\d\\d-\\d\\d))"
позволяют выделить весь телефонный номер ($1) и его отдельные части – код оператора ($2) и собственно номер телефона ($3).

Переменные $1-$9 можно записывать и в выражении шаблона в форме \i, где i – номер переменной. Переменную называет обратной ссылкой.

Пример использования обратной ссылки в регулярных выражениях
Изменим шаблон для номера мобильного телефона следующим образом:
"((\\d{3})-(\\d{3}-(\\d\\d)-\\4))"
Такая запись означает, что последняя пара цифр должна совпадать с предпоследней парой цифр (значением переменой $4). В этом случае телефон 094-996-18-18 будет удовлетворять шаблону, а телефон 094-996-18-19 – не будет.

Переменные $1-$9 не всегда необходимо использовать как результат поиска соответствия шаблону. В случае, когда необходимо сгруппировать какие-либо символы шаблона, но не выполнять для них операции по определению соответствующих переменных (не выполнять для них операцию захвата), используется следующая форма группирования:
(?:символы)

Пример использования операции группирования без захвата в регулярных выражениях
Шаблон
"сет(?:ь|и|ью|ей|ям|ями|ях)"
будет выполнять в строке поиск слова "сеть" во всех падежах единственного и множественного числа, но при этом переменная $1 не создается.

Другим видом группировки является группировка с «заглядыванием вперед». Группирование в этом случае записывается в следующем виде:
шаблон(?=символы)
В этом случае при поиске соответствия шаблону учитываются символы, заданные в скобках и идущие после шаблона, но в результат поиска эти символы не входят. Следующий поиск начинается с позиции, с которой начинаются символы в скобках, т.е. результат «заглядывания вперед» не учитывается.
Вторая форма группировки с «заглядыванием вперед» записывается в следующем виде:
шаблон(?!символы)
В отличие от первой формы символы в скобках не должны содержаться в соответствии шаблону.  В результат поиска эти символы не входят и результат «заглядывания вперед» также не учитывается.

Примеры использования операции группирования «с заглядыванием вперед» в регулярных выражениях
1. Шаблон
"компьютер(?=\\s|[.,;:?!)()])"
(без учета регистра букв) для исходной строки
"Персональный компьютер. Компьютер - это устройство для обработки данных. Компьютерное оборудование выпускается многими фирмами. Суперкомпьютер - это мощный компьютер, содержащий десятки и сотни процессоров."
будет соответствовать шаблону только в том случае, если справа от слова  "компьютер" находится граница слова, т.е. после этого слова должен следовать либо пробельный символ, либо один из знаков препинания. В найденные соответствия пробельные символы и знаки препинания не входят.
В результате поиска в строке будут найдены следующие соответствия:
"Персональный компьютер. Компьютер - это устройство для обработки данных. Компьютерное оборудование выпускается многими фирмами. Суперкомпьютер - это мощный компьютер, содержащий десятки и сотни процессоров."
Символы "Компьютер" в слове "Компьютерное" не соответствуют шаблону, поскольку после символа "р" следует буква, а не пробельный символ или знак препинания.
2. Если в предыдущем примере изменить шаблон следующим образом:
"компьютер(?!\s|[.,;:?!)()])"
то соответствовать  шаблону будут только символы "Компьютер" в слове "Компьютерное", поскольку символ "н", который следует после символа "р" не совпадает ни с одним из символов, указанных в группировке.

Группировка «заглядывание назад» записывается в следующем виде:
(?<=символы) шаблон
В этом случае при поиске соответствия шаблону учитываются символы, заданные в скобках и идущие перед шаблоном, но в результат поиска эти символы не входят. Следующий поиск начинается с первой позиции после шаблона.
Вторая форма группировки с «заглядыванием назад» записывается в следующем виде:
(?<!символы) шаблон
В отличие от первой формы символы в скобках не должны содержаться в соответствии шаблону.  В результат поиска эти символы не входят и результат «заглядывания назад» также не учитывается.

Примеры использования операции группирования «с заглядыванием назад» в регулярных выражениях
1. Для исходной строки, заданной в предыдущем примере зададим следующий шаблон:
"(?iu)(?<=\\s|[.,;:?!)()])компьютер(?=\\s|[.,;:?!)()])"
В результате поиска в строке будут найдены следующие соответствия:
"Персональный компьютер. Компьютер - это устройство для обработки данных. Компьютерное оборудование выпускается многими фирмами. Суперкомпьютер - это мощный компьютер, содержащий десятки и сотни процессоров."
Слово  "Суперкомпьютер" не соответствуют шаблону, поскольку перед символом "к" следует буква, а не пробельный символ или знак препинания.
2. Если изменить шаблон на
"(?iu)(?<!\\s|[.,;:?!)()])компьютер(?=\\s|[.,;:?!)()])"
то только слово  "Суперкомпьютер" будет соответствовать шаблону, поскольку символ перед символом "к" – не пробельный символ и не знак препинания.

Для работы с регулярными выражениями в Java используются классы Pattern, Matcher и PatternSyntaxException пакета java.util.regex.
2.2.6.2. Класс Pattern
2.2.6.2.1. Создание объекта класса Pattern
Объект класса Pattern является откомпилированным представлением шаблона регулярного выражения и создается не с помощью ключевого слова new, а с помощью статических методов compile()класса Pattern.

Метод
public static Pattern compile(String шаблон)
возвращает объект класса Pattern для заданного в параметре шаблона.
Метод
public static Pattern compile(String шаблон, int флажки)
возвращает объект класса Pattern для заданного в параметре шаблона с заданными флажками.
Флажки представлены в Java как статические поля типа int класса Pattern:
•	public static final int CASE_INSENSITIVE (2) – включает поиск соответствия без учета верхнего или нижнего регистра, т.е. строки "abc", "Abc" и "ABC" будут считаться соответствующими регулярному выражению "abc" (при отключенном флажке шаблону будет соответствовать только первая строка);
•	public static final int UNICODE_CASE (64) – если этот флажок включен вместе с флажком CASE_INSENSITIVE, то верхний и нижний регистры букв в коде Unicode не учитываются при поиске соответствия, т.е. строки "строка", "Строка" и "СТРОКА" будут считаться соответствующими регулярному выражению "строка" (при отключенном флажке UNICODE_CASE и включенном флажке CASE_INSENSITIVE шаблону будет соответствовать только строки, содержащие латинские буквы);
•	public static final int UNIX_LINES (1) – при включении этого флажка только символ "\n" учитывается как символ окончания строки, в которой выполняется поиск соответствия;
•	public static final int MULTILINE (8) – если внутри строки, в которой выполняется поиск соответствия, есть символы "\n", то считается что строка  состоит из нескольких строк (если флажок выключен, то считается, что поиск соответствия производится в одной строке, независимо от наличия символов "\n");
•	public static final int LITERAL (16) – все символы шаблона, включая метасимволы, рассматриваются как обычные символы (если флажок выключен, метасимволы в строке обрабатываются при компилировании);
•	public static final int DOTALL (32) – если в шаблоне есть метасимвол ".", то ему будет соответствовать любой символ, включая символ "\n" (если флажок выключен, метасимвол "." будет соответствовать любому символу, исключая символ "\n");
•	public static final int COMMENTS (4) – в строке шаблона, допустимы пробелы и комментарии, начинающиеся с символа "#" до конца строки (при компиляции шаблона пробелы и комментарии будут проигнорированы);
•	public static final int CANON_EQ (128) – при поиске соответствия будет учитываться соответствие между кодом символа и сами символом, т.е. при включенном флажке латинская буква "a" будет соответствовать коду Unicode  этой буквы "\u00E5" в шаблоне.
Если необходимо задать одновременно несколько флажков, то они должны быть разделены знаком операции ИЛИ – "|".

Примеры задания шаблона
1. Pattern pattern1 =  Pattern.compile("abc");
Задание шаблона – строки "abc".
2. Pattern pattern2 =  Pattern.compile("string",
Pattern.CASE_INSENSITIVE);
Задание шаблона – строки "string" с поиском соответствия без учета регистра.
3. Pattern pattern3 =  Pattern.compile("строка",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
Задание шаблона – строки "строка" с поиском соответствия без учета регистра, в том числе и для букв кириллицы.

Флажки можно включать непосредственно в шаблоне, используя следующую синтаксическую форму:
(?строка-символов)
где  символы в строке-символов могут иметь одно из следующих значений
i – для флажка CASE_INSENSITIVE;
d – для флажка UNIX_LINES;
m – для флажка MULTILINE;
s – для флажка DOTALL;
u – для флажка UNICODE_CASE;
x – для флажка COMMENTS.

Пример задания флажков в регулярном выражении
"(?ium)компьютер"
Для шаблона "компьютер" включены флажки CASE_INSENSITIVE, UNICODE_CASE и MULTILINE.
2.2.6.2.2. Методы класса Pattern
Метод
public static boolean matches(String шаблон,
CharSequence строка-поиска)
проверяет соответствие шаблона строке-поиска и возвращает значение true, если строка поиска соответствует шаблону и false – в противном случае.

Пример использования метода match
1. boolean isFound1 = Pattern.matches("a.c", "abc");
Переменная isFound1 получит значение true, т.к. строка "abc"соответствует шаблону "a.c" (между "a" и "c" один произвольный символ).
2. boolean isFound2 = Pattern.matches("a.c", "abbc");
Переменная isFound2 получит значение false, т.к. строка "abc" не соответствует шаблону "a.c" (между "a" и "c" два символа).

Помимо перечисленных методов в классе Pattern определены следующие вспомогательные методы:
•	public String pattern() – возвращает строку шаблона для объекта класса Pattern;
•	public int flags() – возвращает числовое значения флажка для объекта класса Pattern; (если задано несколько флажков, возвращает сумму их числовых значений);
•	public static String quote(String строка) – возвращает строковый шаблон для заданной строки (см. поле LITERAL);
•	public String[] split(CharSequence строка-поиска) – создает из строки-поиска массив, разделенный на элементы по шаблону, заданному в объекте класса Pattern;
•	public String[] split(CharSequence строка-поиска, int предел) – создает из строки-поиска массив, разделенный на элементы по шаблону, заданному в объекте класса Pattern, и с заданным в параметре предел количеством элементов (если значение параметра больше или равно количеству элементов, либо меньше 0, выводятся все элементы, если меньше количества элементов – все оставшиеся соответствия выводятся в последнем элементе массива);
•	public String toString() – возвращает строковое представление откомпилированного шаблона.

Примеры использования вспомогательных методов
1.   	// Задание шаблона
Pattern pattern4 =  Pattern.compile("строк?",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
             // Получение значения шаблона
String patternValue = pattern4.pattern();
   	// Получение строкового значения шаблона
String stringPattern = pattern4.toString();
// Получение значения флажков
int flags = pattern4.flags();
   	// Вывод результатов
System.out.println("patternValue='" + patternValue +
"' stringPattern='" + stringPattern +
"' flags=" + flags);
Вывод этого фрагмента будет иметь следующий вид:
patternValue='строк?' stringPattern='строк?' flags=66 	Значение переменной flags будет равно сумме значений для поля CASE_INSENSITIVE (2) и поля UNICODE_CASE (64).
2. boolean isFound3 = Pattern.matches("строк?", "строк");
boolean isFound4 = Pattern.matches("строк?", "строк?");
Переменная isFound3 получит значение true (метасимвол "?" в шаблоне означает, что символ "к" должен встречаться в строке один раз или не встречаться вообще). Переменная isFound4 получит значение false (символ "?" в строке не соответствует шаблону).
// Получение строкового значения шаблона
String literalPattern = Pattern.quote("строк?");
boolean isFound5 =
Pattern.matches(literalPattern, "строк");
boolean isFound6 =
Pattern.matches(literalPattern, "строк?");
Переменная isFound5 получит значение false , а переменная isFound6 получит значение true (метасимвол "?" в шаблоне трактуется как обычный символ).
3. 	// Задания шаблона для разделителя строк
// (пробел или запятая,пробел)
Pattern pattern5 = Pattern.compile(" |, ");
// Исходная строка
String inString = "Использование квантификаторов, " +
            "классов и групп в шаблоне";
// Разделение исходной строки на компоненты
String outString[] = pattern5.split(inString);
// Вывод компонент строки
for (int i = 0; i < outString.length; i++) {
System.out.println("outString[" + i + "]='" +
   	outString[i] + "'");
}
Вывод этого фрагмента программы будет иметь следующий вид:
outString[0]='Использование'
outString[1]='квантификаторов'
outString[2]='классов'
outString[3]='и'
outString[4]='групп'
outString[5]='в'
outString[6]='шаблоне'
4. При замене предложения вызова метода split() на следующее предложение:
String outString[] = pattern5.split(inString, 4);
вывод фрагмента примет следующий вид:
outString[0]='Использование'
outString[1]='квантификаторов'
outString[2]='классов'
outString[3]='и групп в шаблоне'
2.2.6.3. Класс Matcher
2.2.6.3.1. Создание объекта класса Matcher
Класс Matcher обеспечивает выполнение поиска или замены соответствия заданному объектом класса Pattern шаблону.
Объект класса Matcher создается с помощью метода
public Matcher matcher(CharSequence строка-поиска)
класса Pattern для строки-поиска.
Строковое представление объекта класса Matcher можно получить с помощью метода
public String toString().
2.2.6.3.2. Операции с регионами
Поиск соответствия выполняется в подстроке исходной строки, называемой регионом (region). По умолчанию регионом является вся вводимая последовательность символов.
Установка границ региона выполняется с помощью метода
public Matcher region(int начальный-индекс, int конечный-индекс)
Этот метод возвращает объект класса Matcher для подстроки, начинающейся с начального-индекса и заканчивающуюся индексом, на единицу меньшим, чем конечный-индекс.
Получить текущие значения начального и конечного индексов региона для объекта класса Matcher можно с помощью методов
public int regionStart()
и
public int regionEnd().
Характер границ региона можно установить с помощью методов useAnchoringBounds() и useTransparentBounds().
Метод
public Matcher useAnchoringBounds(boolean флажок)
Если параметр флажок установлен в true, то для задания шаблона на границах региона можно использовать анкеры "^" и "$". В противном случае (если флажок установлен в false) соответствие анкерам "^" и "$" на границах региона не проверяется. По умолчанию значение флажка равно true.
Метод
public Matcher useTransparentBounds(boolean флажок)
Если параметр флажок установлен в true, границы региона являются прозрачными для шаблонов, содержащих граничные условия, а также «заглядывание вперед» и «заглядывание назад», в том числе и за границы региона. В противном случае (если флажок установлен в false) границы региона будут непрозрачными, т.е. операции с символами за границами региона запрещены. По умолчанию значение флажка равно false.
Методы
public boolean hasAnchoringBounds()
и
public boolean hasTransparentBounds()
позволяют проверить являются ли границы анкерными или прозрачными. При выполнении условия методы возвращают true, в противном случае – false.
2.2.6.3.3. Методы поиска соответствий
Метод
public boolean matches()
выполняет для объекта класса Matcher поиск на соответствие всего региона, начиная с начала региона. Возвращает true, если соответствие найдено и false – в противном случае.
Метод
public boolean lookingAt()
так же, как метод matches(), выполняет для объекта класса Matcher поиск, начиная с начала региона на наличие шаблона в регионе, но необязательно соответствия всего региона шаблону. Возвращает true, если соответствие найдено и false – в противном случае.

Пример использования методов matches() и lookingAt()
// Исходная строка
String inStr = "строка 1; Строка 2; СТРОКА 3";
// Задание шаблона для исходной строки
Pattern pattern6 =  Pattern.compile("строка",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
// Создание объекта класса Matcher для всей строки
Matcher matcher1 = pattern6.matcher(inStr);
// Проверка с помощью метода matches()
// соответствия всей строки шаблону
boolean isFound7 = matcher1.matches();
// Проверка с помощью метода lookingAt()
// наличия шаблона в строке
boolean isFound8 = matcher1.lookingAt();
// Вывод границ региона для matcher1
// и результатов проверки
System.out.println("Регион для matcher1: индекс начала=" +
matcher1.regionStart() + "  индекс окончания=" +
matcher1.regionEnd() + "\nisFound для matches():   " +
isFound7 + "\nisFound для lookingAt(): " + isFound8);
// Выделение региона в строке inStr
Matcher regionMatcher = matcher1.region(10, 16);
// Проверка с помощью метода matches()
// соответствия региона шаблону
boolean isFound9 = regionMatcher.matches();
// Вывод границ региона для regionMatcher
// и результата проверки
System.out.println("\nРегион для regionMatcher: " +
"индекс начала=" + regionMatcher.regionStart() +
"  индекс окончания=" + regionMatcher.regionEnd() +
"\nisFound для matches(): " + isFound9);
Вывод этого фрагмента программы будет иметь следующий вид:
Регион для matcher1: индекс начала=0  индекс окончания=28
isFound для matches():   false
isFound для lookingAt(): true

Регион для regionMatcher: индекс начала=10
индекс окончания=16
isFound для matches(): true
Метод
public boolean find()
выполняет для объекта класса Matcher поиск, начиная с начала региона или, если предыдущий вызов метода был успешным, и объект класса Matcher не был сброшен, с первого символа после найденного предыдущего соответствия. Возвращает true, если соответствие найдено и false – в противном случае.
Метод
public boolean find(int начальный-индекс)
выполняется так же,  как и предыдущей метод, но поиск начинается не с начала региона, а заданного начального-индекса. Если необходимо найти все соответствия шаблону в строке, начиная с начального-индекса, то этот метод можно использовать только для поиска первого соответствия. Все остальные соответствия определяются с помощью метода find() без параметров.
Характеристики найденного соответствия, полученного с помощью методов matches(),lookingAt() и find() можно определить с помощью следующих методов:
•	public String group() – возвращает предыдущее найденное соответствие;
•	public String group(int номер-группы) – возвращает предыдущее найденное соответствие для заданного номера-группы (группы нумеруются слева направо, начиная с 1; если задан 0, метод выполняется аналогично предыдущему методу);
•	public int start() – возвращает начальный индекс в строке поиска предыдущего найденного соответствия;
•	public int start(int номер-группы) – возвращает начальный индекс в строке поиска предыдущего найденного соответствия для заданного номера-группы (группы нумеруются слева направо, начиная с 1; если задан 0, метод выполняется аналогично предыдущему методу);
•	public int end() – возвращает конечный индекс в строке поиска предыдущего найденного соответствия;
•	public int end(int номер-группы) – возвращает конечный индекс в строке поиска предыдущего найденного соответствия для заданного номера-группы (группы нумеруются слева направо, начиная с 1; если задан 0, метод выполняется аналогично предыдущему методу);
•	public int groupCount() – возвращает количество групп в объекте класса Matcher.
Метод
public Pattern pattern()
возвращает шаблон, соответствующий объекту класса Matcher.
Метод
public Matcher usePattern(Pattern новый-шаблон)
заменяет шаблон для объекта класса Match на новый-шаблон.
Метод
public boolean hitEnd()
возвращает true, если поиск соответствия затронул окончание строки поиска и false – в противном случае.
Метод
public boolean requireEnd()
возвращает true и, если соответствие было найдено, то дальнейший поиск может привести к потере соответствия. Если метод возвращает false и соответствие было найдено, то дальнейший поиск не приведет  привести к потере соответствия. Если соответствия не было найдено, метод не имеет значения.

Примеры использования метода find(), методов определения характеристик соответствия и методов задания опций для границ регионов
1. 	// Исходная строка
String inStr = "строка 1; Строка 2; СТРОКА 3";
// Задание шаблона для исходной строки
Pattern pattern6 =  Pattern.compile("строка",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE
// Создание объекта класса Matcher для всей строки
Matcher matcher1 = pattern6.matcher(inStr);
// Соответствия шаблону в строке не найдено
 boolean isFound10 = false;
// Начальный индекс соответствия шаблону в строке
int matchIndex = 1;
// Цикл поиска соответствий в строке
while (matcher1.find()) {
// Определение предыдущего соответствия
String matchValue = matcher1.group();
// Определение начального индекса
// предыдущего соответствия
int matchBeginIndex = matcher1.start();
// Определение конечного индекса
// предыдущего соответствия
int matchEndIndex = matcher1.end();
// Вывод предыдущего соответствия
// и его характеристик
System.out.println("Соответствие " + matchIndex +
": '" + matchValue + "'  индекс начала=" +
matchBeginIndex + "  индекс окончания=" +
matchEndIndex);
// Найдено соответствие в строке
isFound10 = true;
          	// Увеличение индекса соответствия
   	// шаблону в строке на 1
      	matchIndex++;
}
// Если ни одного соответствия шаблону
// в строке не найдено
if(!isFound10){
// Вывод сообщения
    	System.out.println("Не найдено ни одного " +
"соответствия шаблону");
	}
В этом фрагменте программы выполняется поиск и вывод всех соответствий шаблону в строке. Вывод фрагмента будет иметь следующий вид:
Соответствие 1: 'строка'  индекс начала=0
индекс окончания=6
Соответствие 2: 'Строка'  индекс начала=10
индекс окончания=16
Соответствие 3: 'СТРОКА'  индекс начала=20
индекс окончания=26
2. Если в предыдущем пункте необходимо выполнить поиск всех соответствий, начиная с индекса 5 в строке inStr, то необходимо изменить цикл следующим образом:
// Первый вызов метода find()
// (начало поиска с индекса 5)
matcher1.find(5);
// Цикл поиска соответствий в строке
do {
        	// Определение предыдущего соответствия
String matchValue = matcher1.group();
// Определение начального индекса
   	// предыдущего соответствия
      	int matchBeginIndex = matcher1.start();
// Определение конечного индекса
// предыдущего соответствия
       	int matchEndIndex = matcher1.end();
// Вывод предыдущего соответствия
// и его характеристик
System.out.println("Соответствие " + matchIndex +
    	": '" + matchValue + "'  индекс начала=" +
     matchBeginIndex + "  индекс окончания=" +
matchEndIndex);
       	// Найдено соответствие в строке
          	isFound10 = true;
         	// Увеличение индекса соответствия
    	// шаблону в строке на 1
   	matchIndex++;
}
    	// Проверка условия окончания цикла
while (matcher1.find());
Вывод измененного фрагмента будет иметь следующий вид:
Соответствие 1: 'Строка'  индекс начала=10
индекс окончания=16
Соответствие 2: 'СТРОКА'  индекс начала=20
индекс окончания=26
3. 	// Исходная строка - ФИО и номера телефонов
String teleponeNumbers = "Иванов И.И.: 069-173-42-05;" +
"Петров П.П.: 035-979-15-46; Сидоров С.С.: 044-227-17-32";
            // Задание шаблона для исходной строки
Pattern pattern7 =
Pattern.compile("([А-Я][а-я]+ [А-Я]\\.[А-Я]\\.): " +
"(\\d{3})-(\\d{3}-\\d\\d-\\d\\d)");
            // Создание объекта класса Matcher
    	// для исходной строки
Matcher matcher2 = pattern7.matcher(teleponeNumbers);
            // Цикл поиска соответствий в строке
for (int i = 1; matcher2.find(); i++) {
    		// Определение предыдущего соответствия для ФИО
         	String name = matcher2.group(1);
                	// Определение начального индекса
       	// предыдущего соответствия для ФИО
            int nameBeginIndex1 = matcher2.start(1);
                	// Определение конечного индекса
       	// предыдущего соответствия для ФИО
            int nameEndIndex = matcher2.end(1);
         	// Определение кода вызова
            String callIndex = matcher2.group(2);
                	// Определение номера телефона
            String telephone = matcher2.group(3);
                	// Вывод результатов поиска
   	System.out.println("ФИО: '" + name +
    	"'  индекс начала=" + nameBeginIndex1 +
    	"  индекс окончания=" + nameEndIndex);
    	System.out.println("    Код вызова: " +
    	callIndex + "    Телефон: " + telephone);
}
В этом фрагменте программы определяются и выводятся компоненты исходной строки – списка телефонных номеров: фамилия и инициалы абонента (ФИО), код вызова и номер телефона. Компоненты представлены в шаблоне как группы, заключенные в круглые скобки. Вывод фрагмента имеет следующий вид:
ФИО: 'Иванов И.И.'  индекс начала=0  индекс окончания=11
    Код вызова: 069    Телефон: 173-42-05
ФИО: 'Петров П.П.'  индекс начала=27  индекс окончания=38
    Код вызова: 035    Телефон: 979-15-46
ФИО: 'Сидоров С.С.'  индекс начала=55  индекс окончания=67
    Код вызова: 044    Телефон: 227-17-32
4. 	// Исходная строка - ФИО и номера телефонов абонента
String teleponeNumbers = "Иванов И.И.: 069-173-42-05;" +
"Петров П.П.: 035-979-15-46; Сидоров С.С.: 044-227-17-32" +
"Петренко Н.Ф.: 044-598-52-13; Король А.Г.: 077-342-81-00";
            // Задание шаблона для исходной строки
Pattern abonentPattern =
Pattern.compile("[А-Я][а-я]+ [А-Я]\\.[А-Я]\\.: " +
"(\\d{3})-(\\d{3}-\\d\\d-\\d\\d)");
            // Создание объекта класса Matcher
    	// для исходной строки
Matcher abonentMatcher =
bonentPattern.matcher(teleponeNumbers);
            // Установка начального индекса
    	// для поиска соответствия шаблону в строке
int startIndex = 0;
            // Цикл поиска соответствий в строке
for (int i = 1; abonentMatcher.find(startIndex); i++) {
                	// Определение предыдущего
// соответствия для абонента
  	String abonentString = abonentMatcher.group();
                	// Определение начального индекса
       	// предыдущего соответствия для абонента
            int abonentBeginIndex = abonentMatcher.start();
                	// Определение конечного индекса
      	// предыдущего соответствия для абонента
            int abonentEndIndex = abonentMatcher.end();
                	// Задание региона для абонента
            Matcher abonentRegion =
     abonentMatcher.region(abonentBeginIndex,
 	abonentEndIndex);
                	// Установление анкерных границ
         	// региона для абонента
            abonentRegion =
     abonentRegion.useAnchoringBounds(true);
                	// Задание шаблона для поиска ФИО абонента
        	// в начале региона
            Pattern namePattern =
     Pattern.compile("^Петр");
                	// Установка шаблона поиска фамилии в регионе
            abonentRegion.usePattern(namePattern);
                	// Если шаблон найден в регионе абонента
   	if(abonentRegion.lookingAt()) {
                    		// Вывод результатов поиска
        	System.out.println("Найден -> " + abonentString);
         	}
                	// Восстановление шаблона абонента
   	abonentMatcher.usePattern(abonentPattern);
         	// Установка нового значения начального индекса
         	// для поиска соответствия шаблону в строке
            startIndex = abonentEndIndex;
}
В этом фрагменте программы выполняется поиск абонента, фамилия которого начинается на символы "Петр". Сначала по шаблону abonentPattern получается запись абонента, потом из этой записи образуется регион с анкерными границами, в котором ищутся символы "Петр" в начале региона. Если регион удовлетворяет критерию поиска, его содержимое выводится на экран.
Вывод фрагмента имеет следующий вид:
Найден -> Петров П.П.: 035-979-15-46
Найден -> Петренко Н.Ф.: 044-598-52-13
4. 	// Исходная строка - сведения о студентах:
    	// фамилия и инициалы, пол, дата рождения
String studentChars = "Иванов И.И.;м;13.07.1089" +
"\nПетрова П.П.;ж;25.01.1990\nСидоров С.С.;м;01.09.1089" +
"\nКнязь Н.Ф.;ж;11.04.1990\nКороль А.Г.;м;04.12.1089";
            // Задание шаблона для исходной строки
Pattern namePattern =
Pattern.compile("^[А-Я][а-я]+ [А-Я]\\.[А-Я]\\.",
Pattern.MULTILINE);
            // Создание объекта класса Matcher
   	// для исходной строки
Matcher studentMatcher =
namePattern.matcher(studentChars);
            // Установка начального индекса
            // для поиска соответствия шаблону в строке
int startIndex = 0;
   	// Цикл поиска соответствий в строке
for (int i = 1; studentMatcher.find(startIndex); i++) {
       		// Определение предыдущего соответствия
// для студента
String studentString = studentMatcher.group();
      		// Определение начального индекса
    		// предыдущего соответствия для студента
int studentBeginIndex = studentMatcher.start();
          		// Определение конечного индекса
    		// предыдущего соответствия для студента
int studentEndIndex = studentMatcher.end();
       		// Задание региона для студента
 	Matcher studentRegion =
studentMatcher.region(studentBeginIndex,
studentEndIndex);
         		// Установление прозрачных границ
 		// региона для студента
studentRegion =
studentRegion.useTransparentBounds(true);
                	// Задание шаблона для поиска ФИО студента
        	// с "заглядыванием вперед" для
         	// определения пола студента
            Pattern genderPattern =
     Pattern.compile("[А-Я][а-я]+ [А-Я]\\.[А-Я]\\.(?=;м)");
      	// Установка шаблона поиска фамилии в регионе
    	studentRegion.usePattern(genderPattern);
                	// Если шаблон найден в регионе студента
            if(studentRegion.lookingAt()) {
                    		// Вывод результатов поиска
       	System.out.println("Найден студент -> " +
studentString);
            }
       	// Восстановление шаблона студента
            studentMatcher.usePattern(namePattern);
                	// Установка нового значения начального индекса
         	// для поиска соответствия шаблону в строке
            startIndex = studentEndIndex;
}
В этом фрагменте программы выполняется поиск и вывод на экран студентов – мужчин. Сначала по шаблону studentPattern получается запись студента, потом из этой записи образуется регион с прозрачными границами, в котором с «заглядыванием вперед» ищутся символы ";м" за пределами региона. Если регион удовлетворяет критерию поиска, его содержимое выводится на экран.
Вывод фрагмента имеет следующий вид:
Найден студент -> Иванов И.И.
Найден студент -> Сидоров С.С.
Найден студент -> Король А.Г.
2.2.6.3.4. Методы замены
Методы класса Matcher позволяют не только выполнить поиск в строке по заданному шаблону, но и заменить найденные соответствия заданными последовательностями символов – строками замены.
Так, методы
public String replaceFirst(String строка-замены)
и
public String replaceAll(String строка-замены)
позволяют заменить только первое соответствие или все соответствия в строке поиска строкой-замены. Оба метода возвращают измененную строку.

Примеры использования методов replaceFirst()  и replaceAll()
1. 	// Исходная строка
String inStr = "строка 1; Строка 2; СТРОКА 3";
          	// Задание шаблона для исходной строки
Pattern firstStringPattern = Pattern.compile("строка",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
        	// Создание объекта класса Matcher для всей строки
Matcher firstStringMatcher =
firstStringPattern.matcher(inStr);
       	// Замена первого соответствия
    	// заданной строкой замены для новой строки
String newStr =
firstStringMatcher.replaceFirst("Первая строка");
       	// Вывод новой строки
System.out.println("Новая строка: '" + newStr + "'");
В этом фрагменте программы выполняется поиск соответствия шаблону "строка" (без учета регистра) в строке inStr. Первое найденное соответствие (и только оно) заменяется на строку "Первая строка". Вывод фрагмента имеет следующий вид:
Новая строка: 'Первая строка 1; Строка 2; СТРОКА 3'
2. 	// Исходная строка - ФИО и номера телефонов абонента
String teleponeNumbers = "Иванов И.И.: 069-173-42-05;" +
"Петров П.П.: 035-979-15-46; Сидоров С.С.: 044-227-17-32";
            // Задание шаблона с группами для исходной строки
Pattern abonentPattern =
Pattern.compile("(\\d{3})-(\\d{3})-(\\d\\d)-(\\d\\d)");
            // Создание объекта класса Matcher для исходной строки
Matcher abonentMatcher =
abonentPattern.matcher(teleponeNumbers);
            // Установка начального значения
     // новой строки
String newTeleponeNumbers = null;
            // Цикл поиска соответствий в строке
for (int i = 1; abonentMatcher.find(); i++) {
                	// Внесение изменения в новую строку
         	// для текущего найденного соответствия
            newTeleponeNumbers =
     abonentMatcher.replaceAll("($1)-$2-$3$4");
}
        	// Вывод новой строки
System.out.println("Новая строка: '" +
newTeleponeNumbers + "'");
В этом фрагменте программы выполняется поиск в строке teleponeNumbers соответствия шаблону номера телефона, в котором определены четыре группы: первые три цифры номера ($1), следующие три цифры номера ($2),  следующие две цифры номера ($3) и последние две цифры номера ($3). Для всех найденных соответствий номер телефона изменяется следующим образом: первые три цифры номера ($1) заключаются в скобки, а последние четыре цифры номера ($3 и $4) записываются слитно (без символа  "-" между ними). Вывод фрагмента имеет следующий вид:
Новая строка: 'Иванов И.И.: (069)-173-4205;
Петров П.П.: (035)-979-1546;Сидоров С.С.: (044)-227-1732'
Метод
public Matcher appendReplacement(StringBuffer новая-строка,
String строка-замены)
формирует новую-строку по следующему алгоритму:
•	пересылает символы строки поиска в новую-строку, начиная с конечной позиции (append position) до символа на единицу меньшего, чем символ, определяемого методом start() объекта Match;
•	затем к новой строке добавляется строка-замены;
•	после этого конечная позиция в новой строке становится равной позицией, определяемой методом end() объекта Match.
В начале просмотра и замены значение конечной позиции равно 0.
Метод
public StringBuffer appendTail(StringBuffer новая-строка)
пересылает символы строки поиска в новую-строку, начиная с конечной позиции и до конца строки поиска. Этот метод используется вместе с методом appendReplacement() для завершения процесса поиска и замены в строке.
Методы appendReplacement() и appendTail() выполняют те же действия, что и методы replaceFirst() и replaceAll(), однако они позволяют управлять как количеством замен, так самими заменами в строке.

Пример использования методов appendReplacement() и appendTail()
// Исходная строка
String inStr = "строка 1; СТрока 2; СТРОКА 3;" +
"сТрока 4; сТРОКА 5; Строка 6; СТрокА 7";
         	// Задание шаблона для исходной строки
Pattern stringPattern =  Pattern.compile("строка",
Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
// Создание объекта класса Matcher для всей строки
Matcher stringMatcher =
stringPattern.matcher(inStr);
       	// Создание новой строки
StringBuffer newStr = new StringBuffer();
   	// Цикл поиска соответствий и замены в строке
for (int i = 1; stringMatcher.find(); i++) {
              	// Получение текущего соответствия
          // в исходной строке
  	String currentMatch = stringMatcher.group();
                    	// Если соответствие имеет допустимую форму
        	if(currentMatch.equals("строка") ||
    	currentMatch.equals("Строка") ||
    	currentMatch.equals("СТРОКА"))
                        	// Оставить форму без изменения
        	stringMatcher.appendReplacement(newStr,
currentMatch);
   	else {
                        	// Если первый символ соответствия -
              	// строчная буква
                    	if(currentMatch.charAt(0) == 'с')
                            		// Замена соответствия строкой "строка"
                        	stringMatcher.appendReplacement(newStr,
"строка");
                            	// Если первый символ соответствия -
               // заглавная буква
                        else if(currentMatch.charAt(0) == 'С')
                            		// Замена соответствия строкой "Строка"
                        	stringMatcher.appendReplacement(newStr,
"Cтрока");
  	}
}
         	// Добавление остатка исходной строки к новой строке
stringMatcher.appendTail(newStr);
         	// Вывод новой строки
System.out.println("Новая строка: '" + newStr + "'");
В этом фрагменте программы выполняется поиск соответствия шаблону "строка" (без учета регистра) в строке inStr. Если соответствие имеет одну из допустимых форм, замена производится на допустимую форму. В противном случае, если соответствие начинается на строчную букву, вся строка заменяется на форму, состоящую из одних строчных букв, иначе выполняется замена на строку, в которой первая буква –заглавная, а остальные – строчные. Вывод фрагмента имеет следующий вид:
Новая строка: 'строка 1; Cтрока 2; СТРОКА 3;
строка 4; строка 5;Строка 6; Cтрока 7'
В классе Matcher определены также следующие вспомогательные методы:
•	public static String quoteReplacement(String строка-замены) – преобразует строку замены в строковую форму, в которой метасимволы, такие как "$", рассматриваются как обычные символы (действует аналогично методу quote() класса Pattern) и возвращает измененную строку;
•	public Matcher reset() – сбрасывает все хранимые в объекте класса Matcher данные, устанавливает конечную позицию в 0, регионом становится вся строка поиска (однако на состояние анкерной границы и границы прозрачности сброс не влияет) и возвращает измененный объект класса Matcher;
•	public Matcher reset(CharSequence строка-поиска) – выполняет те же действия, что и предыдущий метод, но задает для объекта новую последовательность символов поиска.
2.2.6.4. Класс PatternSyntaxException
Класс PatternSyntaxException бросает исключение, если регулярное выражение (шаблон) содержит синтаксическую ошибку.
В классе определены следующие методы:
•	public String getPattern() – возвращает шаблон, содержащий ошибку;
•	public String getDescription() – возвращает описание ошибки;
•	public int getIndex() – возвращает позицию символа ошибки в шаблоне;
•	public String getMessage() – возвращает сообщение об ошибке, содержащее все перечисленные выше компоненты: описание ошибки и ее индекс, шаблон, содержащий ошибку и визуальную индикацию индекса ошибки внутри шаблона.

Пример использования класса PatternSyntaxException для вывода параметров ошибки в регулярном выражении
try {
                	// Задание шаблона для исходной строки
            Pattern errorPattern =  Pattern.compile("ab|*d");
} catch(PatternSyntaxException e) {
   	System.out.println("Неверный шаблон: '" +
     e.getPattern() + "'");
     System.out.println("Описание ошибки: " +
     e.getDescription());
     System.out.println("Позиция ошибки: " +
     e.getIndex());
     System.out.println("Сообщение об ошибке:\n" +
     e.getMessage());
}
В этом фрагменте ошибка в задании шаблона errorPattern (перед метасимволом "*" должен обязательно быть какой-либо обычный символ) приводит к переходу в блок catch и выводу характеристик ошибки:
Неверный шаблон: 'ab|*d'
Описание ошибки: Dangling meta character '*'
Позиция ошибки: 3
Сообщение об ошибке:
Dangling meta character '*' near index 3
ab|*d
   ^
2.2.6.5. Методы класса String для работы с регулярными выражениями
Для работы с регулярными выражениями в классе String определены следующие методы:
•	public boolean matches(String шаблон) – если объект класса String соответствует шаблону, возвращает значение true, в противном случае возвращает false (действует аналогично методу matches() класса  Pattern);
•	public String[] split(String шаблон) – создает для объекта класса String массив строк, разделенный на элементы по заданному шаблону (действует аналогично соответствующему методу split() класса  Pattern);
•	public String[] split(String шаблон, int предел) – создает для объекта класса String массив строк, разделенный на элементы по заданному шаблону, и с заданным в параметре предел количеством элементов (если значение параметра больше или равно количеству элементов, либо меньше 0, выводятся все элементы, если меньше количества элементов – все оставшиеся соответствия выводятся в последнем элементе массива) (действует аналогично соответствующему методу split() класса  Pattern);
•	public String replaceFirst(String шаблон, String строка-замены) – заменяет в объекте String первое соответствие шаблону на строку-замены и возвращает измененную строку (действует аналогично методу replaceFirst () класса  Match);
•	public String replaceAll(String шаблон, String строка-замены) – заменяет в объекте String все соответствия шаблону на строку-замены и возвращает измененную строку (действует аналогично методу replaceAll() класса  Match).

Пример использования метода replaceFirst() класса String для замены в строках с использованием регулярных выражений
// Исходная строка
 String inStr = "строка 1; Строка 2; СТРОКА 3";
            // Замена первого соответствия в исходной строке
 String newStr =
inStr.replaceFirst("строка|Строка|СТРОКА",
"Первая строка");
         	// Вывод новой строки
System.out.println("Новая строка: '" + newStr + "'");
Вывод этого фрагмента программы имеет следующий вид:
Новая строка: 'Первая строка 1; Строка 2; СТРОКА 3'

